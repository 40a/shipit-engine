#!/usr/bin/env ruby

# Usage: kubernetes-deploy <app's namespace> <kube context>

# Prerequisites:
#  - kubectl binary must be available in the shipit machine's path
#  - ENV['KUBECONFIG'] must point to a valid kubeconfig file
#  - The kubeconfig file must contain a named context for each cluster you want to deploy to
#  - The users needed by the named contexts must already be authorized outside this script

# Optionally, the following variables can be used to override script defaults:
#  - ENV['K8S_TEMPLATE_FOLDER']: location of Kubernetes files to deploy. Default is config/deploy/#{environment}.

require 'open3'
require 'securerandom'
require 'erb'
require 'json'
require 'yaml'
require 'shellwords'
require 'tempfile'
require 'logger'
require 'pry'

class KubernetesDeploy
  class FatalDeploymentError < StandardError; end

  # Things removed from default prune whitelist:
  # core/v1/Namespace -- not namespaced
  # core/v1/PersistentVolume -- not namespaced
  # core/v1/Endpoints -- not managed manually
  # core/v1/PersistentVolumeClaim -- want to leave these alone?
  # core/v1/ReplicationController -- old resource we don't use
  # extensions/v1beta1/ReplicaSet -- not managed manually
  # core/v1/Secret -- may have been kubectl applied (by an admin) and will never be in the repo
  PRUNE_WHITELIST = %w(
    core/v1/ConfigMap
    core/v1/Pod
    core/v1/Service
    batch/v1/Job
    extensions/v1beta1/DaemonSet
    extensions/v1beta1/Deployment
    extensions/v1beta1/HorizontalPodAutoscaler
    extensions/v1beta1/Ingress
    apps/v1beta1/StatefulSet
  ).freeze

  PREDEPLOY_SEQUENCE = %w(
    secret
    configmap
    persistentvolumeclaim
    pod
  )

  def initialize(namespace:, environment:, current_sha:, template_folder: nil, kubeconfig:, context:)
    @namespace = namespace
    @context = context
    @current_sha = current_sha
    @kubeconfig = kubeconfig
    @template_path = File.expand_path('./' + (template_folder || "config/deploy/#{environment}"))
    # Max length of podname is only 63chars so try to save some room by truncating sha to 8 chars
    @id = current_sha[0...8] + "-#{SecureRandom.hex(4)}" if current_sha
    @current_phase = 0
  end

  def run
    phase_heading("Validating configuration")
    validate_configuration

    phase_heading("Configuring kubectl")
    set_kubectl_context
    validate_namespace

    phase_heading("Parsing deploy content")
    resource_map = generate_resource_map
    status = DeploymentStatus.new(resource_map.values.flatten, @namespace, @kubeconfig)
    status.update

    phase_heading("Predeploying priority resources")
    priority_resources = resource_map.select { |type, r| PREDEPLOY_SEQUENCE.include?(type) }
    predeploy_priority_resources(priority_resources)
    status.update
    # status.poll_for_completion!(only: priority_resources.values.flatten)

    phase_heading("Deploying all resources")
    apply_templates(resource_map.values.flatten, prune: true)
    status.update
    # status.poll_for_completion!
  rescue FatalDeploymentError => error
    logger.fatal(error.message)
    exit 1
  end

  def template_variables
    {
      'current_sha' => @current_sha,
      'deployment_id' => @id,
    }
  end

  private

  def predeploy_priority_resources(resource_map)
    PREDEPLOY_SEQUENCE.each do |resource_type|
      apply_templates(resource_map[resource_type]) if resource_map.key?(resource_type)
    end
  end

  def generate_resource_map
    resource_map = {}
    Dir.foreach(@template_path) do |filename|
      next unless filename.end_with?(".yml.erb") || filename.end_with?(".yml")
      file_content = File.read(File.join(@template_path, filename))

      split_templates(filename, file_content).each do |resource_template|
        rendered_template = File.extname(filename) == ".erb" ? render_erb(resource_template) : resource_template
        f = Tempfile.new(filename)
        f.write(rendered_template)
        f.close
        resource_name, err, st = run_kubectl("apply", "-f", f.path, "--dry-run", "--output=name")
        unless st.success?
          logger.error(rendered_template)
          raise FatalDeploymentError, "Dry run failed for template #{File.basename(f.path)}."
        end

        type, n = resource_name.split("/", 2)
        resource_map[type] ||= []
        resource_map[type] << { name: n, type: type, value: rendered_template, tempfile: f, deployed: false }
      end
    end
    logger.info("Found resource types: #{resource_map.keys.join(", ")}")
    resource_map
  end

  def split_templates(filename, value)
    templates = []
    YAML.load_stream(value) { |doc| templates << YAML.dump(doc) }
    templates
  rescue Psych::SyntaxError => e
    logger.error(value)
    raise FatalDeploymentError, "Template #{filename} cannot be parsed: #{e.message}"
  end

  def validate_configuration
    errors = []
    if @kubeconfig.nil? || !File.file?(@kubeconfig)
      errors << "Kube config not found at #{@kubeconfig}"
    end

    if @current_sha.nil?  || @current_sha.empty?
      errors << "Current SHA must be specified"
    end

    if !File.directory?(@template_path)
      errors << "Template path #{@template_path} doesn't exist"
    elsif Dir.entries(@template_path).select {|file| file =~ /\.yml(.erb)?$/}.size.zero?
      errors << "#{@template_path} doesn't contain valid templates (postfix .yml or .yml.erb)"
    end

    if @namespace.nil? || @namespace.empty?
      errors << "Namespace must be specified"
    end

    if @context.nil? || @context.empty?
      errors << "Context must be specified"
    end

    raise FatalDeploymentError, "Configuration invalid: #{errors.join(", ")}" if errors.length.nonzero?
    logger.info("All required parameters and files are present")
  end

  def apply_templates(templates, prune: false)
    command = ["apply", "--namespace=#{@namespace}"]
    templates.each { |t| command.push("-f", t[:tempfile].path) }
    if prune
      command.push("--prune", "--all")
      PRUNE_WHITELIST.each { |type| command.push("--prune-whitelist=#{type}") }
    end
    logger.info("Applying #{templates.length} templates (prune: #{prune.inspect})")
    out, err, st = run_kubectl(*command)
    raise FatalDeploymentError, err unless st.success?
    logger.info(out)
  end

  def render_erb(content)
    erb_template = ERB.new(content)
    erb_binding = binding
    template_variables.each do |var_name, value|
      erb_binding.local_variable_set(var_name, value)
    end
    erb_template.result(erb_binding)
  end

  def set_kubectl_context
    out, err, st = run_kubectl("config","get-contexts", "-o", "name", namespaced: false)
    available_contexts = out.split("\n")
    if !st.success?
      raise FatalDeploymentError, err
    elsif !available_contexts.include?(@context)
      raise FatalDeploymentError, "Context #{@context} is not available. Valid contexts: #{available_contexts}"
    end

    _, err, st = run_kubectl("config", "use-context", @context, namespaced: false)
    raise FatalDeploymentError, "Kubectl config is not valid: #{err}" unless st.success?
    logger.info("Kubectl configured")
  end

  def validate_namespace
    _, _, st = run_kubectl("get", "namespace", @namespace, namespaced: false)
    raise FatalDeploymentError, "Namespace #{@namespace} does not exist" unless st.success?
    logger.info("Namespace validated")
  end

  def run_kubectl(*args, namespaced: true)
    args = args.unshift("kubectl").push("--kubeconfig=#{@kubeconfig}")
    args.push("--namespace=#{@namespace}") if namespaced
    logger.debug Shellwords.join(args)
    out, err, st = Open3.capture3(*args)
    logger.debug(out.shellescape)
    logger.warn(err) unless st.success?
    [out.chomp, err.chomp, st]
  end

  def phase_heading(phase_name)
    @current_phase += 1
    padding = "-" * ((100 - phase_name.length) / 2)
    logger.info("")
    logger.info("#{padding}Phase #{@current_phase}: #{phase_name}#{padding}")
  end

  def logger
    @logger ||= begin
      l = Logger.new(STDOUT)
      l.level = ENV["DEBUG"] ? Logger::DEBUG : Logger::INFO
      l.formatter = proc do |severity, _datetime, _progname, msg|
        case severity
        when "FATAL" then "\033[0;31m;1m[#{severity}]\t#{msg}\x1b[0m\n"
        when "ERROR", "WARN" then "\033[0;31m[#{severity}]\t#{msg}\x1b[0m\n"
        when "INFO" then "\033[0;36m#{msg}\x1b[0m\n"
        else "[#{severity}]\t#{msg}\n"
        end
      end
      l
    end
  end

  class DeploymentStatus
    def initialize(new_resources, namespace, kubeconfig)
      @new_resources = new_resources
      @namespace = namespace
      @kubeconfig = kubeconfig
    end

    def poll_for_completion!(only: nil)
      resources_to_poll = only || @new_resources.dup
      # get_status until all succeeded or failed or timeout reached
      # raise an error if any outright failed and/or the timeout was reached
      # Get events for failures, or maybe always? See this:
      # st, events = run_kubectl(%(./kubectl get events -o jsonpath='{range .items[?(@.involvedObject.name=="#{r[:name]}")]}{.metadata.creationTimestamp}  {.reason}   {.count}   {.message}{"\\n"}{end}}'))
    end

    def update
      @new_resources.each do |r|
        status = resource_status(r)
        STDOUT.puts("[KUBESTATUS] #{JSON.dump(status)}")
        r[:deployed] = status[:succeeded]
      end
    end

    private

    def resource_status(resource)
      case resource[:type]
      when "configmap"
        _, st = run_kubectl("get", resource[:type], resource[:name], "--output=name")
        status = st.success? ? "Available" : "Unknown"
        { group: "Configmaps", name: resource[:name], exists: st.success?, succeeded: st.success?, failed: false, status: status }
      when "persistentvolumeclaim"
        phase, st = run_kubectl("get", resource[:type], resource[:name], "--output=jsonpath={.status.phase}")
        { group: "Persistent volume claims", name: resource[:name], exists: st.success?, succeeded: phase == "Bound", failed: phase == "Lost", status: phase }
      when "pod"
        out, st = run_kubectl("get", resource[:type], resource[:name], "-a", "--output=jsonpath={.spec.containers[*].name}{\"//\"}{.status.phase}")
        unless out.empty?
          containers, phase = out.split("//")
          logs = {}
          containers.split(/\s+/).each do |c|
            out, _ = run_kubectl("logs", resource[:name], "--timestamps=true")
            logs[c] = out unless out.empty?
          end
        end
        { group: "Bare Pods", name: resource[:name], exists: st.success?, succeeded: phase == "Succeeded", failed: phase == "Failed", status: phase, logs: logs }
      when "service"
        endpoints, st = run_kubectl("get", "endpoints", resource[:name], "--output=jsonpath={.subsets[*].addresses[*].ip}")
        num_endpoints = endpoints.split(/\s+/).length
        { group: "Services", name: resource[:name], exists: st.success?, succeeded: num_endpoints > 0, failed: false, status: "#{num_endpoints} endpoints" }
      when "deployment"
        out, st = run_kubectl("get", resource[:type], resource[:name])
        labels, statuses = out.split("\n")
        statuses = statuses.split(/\s+/)[1..4]
        labels = labels.split(/\s+/)[1..4]
        status = labels.zip(statuses).to_h
        failed = false # TODO: Get this info from pods, and grab pod logs
        { group: "#{resource[:name].capitalize} deployment", exists: st.success?, name: resource[:name], succeeded: statuses.uniq.length == 1, failed: failed, status: status } # TODO: one of these per pod in the deployment?
      else
        { group: "Unknown", name: resource[:name], succeeded: nil, failed: nil, status: "Unknown" }
      end
    end

    def run_kubectl(*args)
      args = args.unshift("kubectl").push("--kubeconfig=#{@kubeconfig}", "--namespace=#{@namespace}")
      out, _, st = Open3.capture3(*args)
      [out.chomp, st]
    end
  end
end

deployment = KubernetesDeploy.new(
  namespace: ARGV[0],
  context: ARGV[1],
  environment: ENV['ENVIRONMENT'],
  current_sha: ENV['REVISION'],
  template_folder: ENV['K8S_TEMPLATE_FOLDER'],
  kubeconfig: ENV['KUBECONFIG']
)
deployment.run
