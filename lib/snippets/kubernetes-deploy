#!/usr/bin/env ruby

# Usage: kubernetes-deploy <app's namespace> <kube context>

# Prerequisites:
#  - kubectl binary must be available in the shipit machine's path
#  - ENV['KUBECONFIG'] must point to a valid kubeconfig file
#  - The kubeconfig file must contain a named context for each cluster you want to deploy to
#  - The users needed by the named contexts must already be authorized outside this script

# Optionally, the following variables can be used to override script defaults:
#  - ENV['K8S_TEMPLATE_FOLDER']: location of Kubernetes files to deploy. Default is config/deploy/#{environment}.

require 'open3'
require 'securerandom'
require 'erb'
require 'json'
require 'yaml'
require 'shellwords'
require 'tempfile'
require 'logger'

class KubernetesDeploy
  class FatalDeploymentError < StandardError; end

  # Things removed from default prune whitelist:
  # core/v1/Namespace -- not namespaced
  # core/v1/PersistentVolume -- not namespaced
  # core/v1/Endpoints -- not managed manually
  # core/v1/PersistentVolumeClaim -- want to leave these alone?
  # core/v1/ReplicationController -- old resource we don't use
  # extensions/v1beta1/ReplicaSet -- not managed manually
  # core/v1/Secret -- may have been kubectl applied (by an admin) and will never be in the repo
  PRUNE_WHITELIST = %w(
    core/v1/ConfigMap
    core/v1/Pod
    core/v1/Service
    batch/v1/Job
    extensions/v1beta1/DaemonSet
    extensions/v1beta1/Deployment
    extensions/v1beta1/HorizontalPodAutoscaler
    extensions/v1beta1/Ingress
    apps/v1beta1/StatefulSet
  ).freeze

  PREDEPLOY_SEQUENCE = %w(
    secret
    configmap
    persistentvolumeclaim
    pod
  )

  def initialize(namespace:, environment:, current_sha:, template_folder: nil, kubeconfig:, context:)
    @namespace = namespace
    @context = context
    @current_sha = current_sha
    @kubeconfig = kubeconfig
    @template_path = File.expand_path('./' + (template_folder || "config/deploy/#{environment}"))
    # Max length of podname is only 63chars so try to save some room by truncating sha to 8 chars
    @id = current_sha[0...8] + "-#{SecureRandom.hex(4)}" if current_sha
  end

  def run
    validate_configuration
    set_kubectl_context
    resource_map = generate_resource_map
    predeploy_priority_resources(resource_map)
    apply_templates(resource_map.values.flatten, prune: true)
  rescue FatalDeploymentError => error
    logger.fatal(error.message)
    exit 1
  end

  def template_variables
    {
      'current_sha' => @current_sha,
      'deployment_id' => @id,
    }
  end

  private

  def predeploy_priority_resources(resource_map)
    PREDEPLOY_SEQUENCE.each do |resource_type|
      apply_templates(resource_map[resource_type]) if resource_map.key?(resource_type)
    end
  end

  def generate_resource_map
    resource_map = {}
    Dir.foreach(@template_path) do |filename|
      next unless filename.end_with?(".yml.erb") || filename.end_with?(".yml")
      file_content = File.read(File.join(@template_path, filename))

      split_templates(filename, file_content).each do |resource_template|
        rendered_template = File.extname(filename) == ".erb" ? render_erb(resource_template) : resource_template
        f = Tempfile.new(filename)
        f.write(rendered_template)
        f.close
        resource_name, err, st = run_kubectl("apply", "-f", f.path, "--dry-run", "--output=name")
        unless st.success?
          logger.error(rendered_template)
          raise FatalDeploymentError, "Dry run failed for template #{File.basename(f.path)}."
        end

        type, n = resource_name.split("/", 2)
        resource_map[type] ||= []
        resource_map[type] << { name: n, type: type, value: rendered_template, tempfile: f, deployed: false }
      end
    end
    resource_map
  end

  def split_templates(filename, value)
    templates = []
    YAML.load_stream(value) { |doc| templates << YAML.dump(doc) }
    templates
  rescue Psych::SyntaxError => e
    logger.error(value)
    raise FatalDeploymentError, "Template #{filename} cannot be parsed: #{e.message}"
  end

  def validate_configuration
    errors = []
    if @kubeconfig.nil? || !File.file?(@kubeconfig)
      errors << "Kube config not found at #{@kubeconfig}"
    end

    if @current_sha.nil?  || @current_sha.empty?
      errors << "Current SHA must be specified"
    end

    if !File.directory?(@template_path)
      errors << "Template path #{@template_path} doesn't exist"
    elsif Dir.entries(@template_path).select {|file| file =~ /\.yml(.erb)?$/}.size.zero?
      errors << "#{@template_path} doesn't contain valid templates (postfix .yml or .yml.erb)"
    end

    if @namespace.nil? || @namespace.empty?
      errors << "Namespace must be specified"
    end

    if @context.nil? || @context.empty?
      errors << "Context must be specified"
    end

    raise FatalDeploymentError, "Configuration invalid: #{errors.join(", ")}" if errors.length.nonzero?
  end

  def apply_templates(templates, prune: false)
    command = ["apply", "--namespace=#{@namespace}"]
    templates.each { |t| command.push("-f", t[:tempfile].path) }
    if prune
      command.push("--prune", "--all")
      PRUNE_WHITELIST.each { |type| command.push("--prune-whitelist=#{type}") }
    end
    run_kubectl(*command)
  end

  def render_erb(content)
    erb_template = ERB.new(content)
    erb_binding = binding
    template_variables.each do |var_name, value|
      erb_binding.local_variable_set(var_name, value)
    end
    erb_template.result(erb_binding)
  end

  def set_kubectl_context
    out, err, st = run_kubectl("config","get-contexts", "-o", "name", namespaced: false)
    available_contexts = out.split("\n")
    if !st.success?
      raise FatalDeploymentError, err
    elsif !available_contexts.include?(@context)
      raise FatalDeploymentError, "Context #{@context} is not available. Valid contexts: #{available_contexts}"
    end

    _, err, st = run_kubectl("config", "use-context", @context, namespaced: false)
    raise FatalDeploymentError, "Kubectl config is not valid: #{err}" unless st.success?
  end

  def run_kubectl(*args, namespaced: true)
    args = args.unshift("kubectl").push("--kubeconfig=#{@kubeconfig}")
    args.push("--namespace=#{@namespace}") if namespaced
    logger.debug Shellwords.join(args)
    out, err, st = Open3.capture3(*args)
    logger.debug(out.shellescape)
    logger.warn(err) unless st.success?
    [out.chomp!, err.chomp!, st]
  end

  def logger
    @logger ||= begin
      l = Logger.new(STDOUT)
      l.level = Logger::DEBUG
      l.formatter = proc do |severity, _datetime, _progname, msg|
        case severity
        when "FATAL" then "\033[0;31m[#{severity}]\t#{msg}\x1b[0m\n"
        when "WARN" then "\033[0;33m[#{severity}]\t#{msg}\x1b[0m\n"
        when "ERROR" then "\033[0;35m[#{severity}]\t#{msg}\x1b[0m\n"
        else "[#{severity}]\t#{msg}\n"
        end
      end
      l
    end
  end
end

deployment = KubernetesDeploy.new(
  namespace: ARGV[0],
  context: ARGV[1],
  environment: ENV['ENVIRONMENT'],
  current_sha: ENV['REVISION'],
  template_folder: ENV['K8S_TEMPLATE_FOLDER'],
  kubeconfig: ENV['KUBECONFIG']
)
deployment.run
